/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.0.4.0 (NJsonSchema v10.0.21.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import {catchError as _observableCatch, mergeMap as _observableMergeMap} from 'rxjs/operators';
import {Observable, of as _observableOf, throwError as _observableThrow} from 'rxjs';
import {Inject, Injectable, InjectionToken, Optional} from '@angular/core';
import {HttpClient, HttpHeaders, HttpResponse, HttpResponseBase} from '@angular/common/http';

export module tictactoe_api_host {
  export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

  @Injectable()
  export class GameService {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;
    private http: HttpClient;
    private baseUrl: string;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl ? baseUrl : 'https://localhost:44350';
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getGame(id: number | undefined): Observable<Game> {
      let url_ = this.baseUrl + '/api/game/get?';
      if (id === null) {
        throw new Error('The parameter \'id\' cannot be null.');
      } else if (id !== undefined) {
        url_ += 'Id=' + encodeURIComponent('' + id) + '&';
      }
      url_ = url_.replace(/[?&]$/, '');

      let options_: any = {
        observe: 'response',
        responseType: 'blob',
        headers: new HttpHeaders({
          'Accept': 'application/json'
        })
      };

      return this.http.request('get', url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processGetGame(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetGame(<any> response_);
          } catch (e) {
            return <Observable<Game>> <any> _observableThrow(e);
          }
        } else {
          return <Observable<Game>> <any> _observableThrow(response_);
        }
      }));
    }

    /**
     * @return Success
     */
    createNewGame(model: AddNewGameCommand): Observable<Game> {
      let url_ = this.baseUrl + '/api/game/new';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(model);

      let options_: any = {
        body: content_,
        observe: 'response',
        responseType: 'blob',
        headers: new HttpHeaders({
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        })
      };

      return this.http.request('post', url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processCreateNewGame(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processCreateNewGame(<any> response_);
          } catch (e) {
            return <Observable<Game>> <any> _observableThrow(e);
          }
        } else {
          return <Observable<Game>> <any> _observableThrow(response_);
        }
      }));
    }

    protected processGetGame(response: HttpResponseBase): Observable<Game> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (<any> response).error instanceof Blob ? (<any> response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }

      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = Game.fromJS(resultData200);
          return _observableOf(result200);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException('A server error occurred.', status, _responseText, _headers);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        }));
      }
      return _observableOf<Game>(<any> null);
    }

    protected processCreateNewGame(response: HttpResponseBase): Observable<Game> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (<any> response).error instanceof Blob ? (<any> response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }

      if (status === 201) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result201: any = null;
          let resultData201 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result201 = Game.fromJS(resultData201);
          return _observableOf(result201);
        }));
      } else if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException('A server error occurred.', status, _responseText, _headers);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        }));
      }
      return _observableOf<Game>(<any> null);
    }
  }

  @Injectable()
  export class StepService {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;
    private http: HttpClient;
    private baseUrl: string;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl ? baseUrl : 'https://localhost:44350';
    }

    /**
     * @return Success
     */
    addNewStep(model: AddNewStepCommand): Observable<StepResult> {
      let url_ = this.baseUrl + '/api/step/move';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(model);

      let options_: any = {
        body: content_,
        observe: 'response',
        responseType: 'blob',
        headers: new HttpHeaders({
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        })
      };

      return this.http.request('put', url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processAddNewStep(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processAddNewStep(<any> response_);
          } catch (e) {
            return <Observable<StepResult>> <any> _observableThrow(e);
          }
        } else {
          return <Observable<StepResult>> <any> _observableThrow(response_);
        }
      }));
    }

    protected processAddNewStep(response: HttpResponseBase): Observable<StepResult> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (<any> response).error instanceof Blob ? (<any> response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }

      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = StepResult.fromJS(resultData200);
          return _observableOf(result200);
        }));
      } else if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException('A server error occurred.', status, _responseText, _headers);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        }));
      }
      return _observableOf<StepResult>(<any> null);
    }
  }

  @Injectable()
  export class UserRegisterService {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;
    private http: HttpClient;
    private baseUrl: string;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl ? baseUrl : 'https://localhost:44350';
    }

    registerWithToken(userAuthData: UserAuthData): Observable<FileResponse> {
      let url_ = this.baseUrl + '/api/UserRegister/register';
      url_ = url_.replace(/[?&]$/, '');

      const content_ = JSON.stringify(userAuthData);

      let options_: any = {
        body: content_,
        observe: 'response',
        responseType: 'blob',
        headers: new HttpHeaders({
          'Content-Type': 'application/json',
          'Accept': 'application/octet-stream'
        })
      };

      return this.http.request('post', url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processRegisterWithToken(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processRegisterWithToken(<any> response_);
          } catch (e) {
            return <Observable<FileResponse>> <any> _observableThrow(e);
          }
        } else {
          return <Observable<FileResponse>> <any> _observableThrow(response_);
        }
      }));
    }

    protected processRegisterWithToken(response: HttpResponseBase): Observable<FileResponse> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (<any> response).error instanceof Blob ? (<any> response).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }

      if (status === 200 || status === 206) {
        const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
        const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
        return _observableOf({fileName: fileName, data: <any> responseBlob, status: status, headers: _headers});
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException('An unexpected server error occurred.', status, _responseText, _headers);
        }));
      }
      return _observableOf<FileResponse>(<any> null);
    }
  }

  export class Game implements IGame {
    id?: number;
    mapId?: number;
    playerOne?: number;
    playerTwo?: number;
    ticTacList?: number[] | undefined;

    constructor(data?: IGame) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property)) {
            (<any> this)[property] = (<any> data)[property];
          }
        }
      }
    }

    static fromJS(data: any): Game {
      data = typeof data === 'object' ? data : {};
      let result = new Game();
      result.init(data);
      return result;
    }

    init(data?: any) {
      if (data) {
        this.id = data['id'];
        this.mapId = data['mapId'];
        this.playerOne = data['playerOne'];
        this.playerTwo = data['playerTwo'];
        if (Array.isArray(data['ticTacList'])) {
          this.ticTacList = [] as any;
          for (let item of data['ticTacList']) {
            this.ticTacList!.push(item);
          }
        }
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['id'] = this.id;
      data['mapId'] = this.mapId;
      data['playerOne'] = this.playerOne;
      data['playerTwo'] = this.playerTwo;
      if (Array.isArray(this.ticTacList)) {
        data['ticTacList'] = [];
        for (let item of this.ticTacList) {
          data['ticTacList'].push(item);
        }
      }
      return data;
    }
  }

  export interface IGame {
    id?: number;
    mapId?: number;
    playerOne?: number;
    playerTwo?: number;
    ticTacList?: number[] | undefined;
  }

  export class AddNewGameCommand implements IAddNewGameCommand {
    playerOne?: string | undefined;
    playerTwo?: string | undefined;
    mapSize?: number;
    mapWinningChain?: number;

    constructor(data?: IAddNewGameCommand) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property)) {
            (<any> this)[property] = (<any> data)[property];
          }
        }
      }
    }

    static fromJS(data: any): AddNewGameCommand {
      data = typeof data === 'object' ? data : {};
      let result = new AddNewGameCommand();
      result.init(data);
      return result;
    }

    init(data?: any) {
      if (data) {
        this.playerOne = data['playerOne'];
        this.playerTwo = data['playerTwo'];
        this.mapSize = data['mapSize'];
        this.mapWinningChain = data['mapWinningChain'];
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['playerOne'] = this.playerOne;
      data['playerTwo'] = this.playerTwo;
      data['mapSize'] = this.mapSize;
      data['mapWinningChain'] = this.mapWinningChain;
      return data;
    }
  }

  export interface IAddNewGameCommand {
    playerOne?: string | undefined;
    playerTwo?: string | undefined;
    mapSize?: number;
    mapWinningChain?: number;
  }

  export class StepResult implements IStepResult {
    gameId?: number;
    nextPlayerId?: number;
    status?: State;

    constructor(data?: IStepResult) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property)) {
            (<any> this)[property] = (<any> data)[property];
          }
        }
      }
    }

    static fromJS(data: any): StepResult {
      data = typeof data === 'object' ? data : {};
      let result = new StepResult();
      result.init(data);
      return result;
    }

    init(data?: any) {
      if (data) {
        this.gameId = data['gameId'];
        this.nextPlayerId = data['nextPlayerId'];
        this.status = data['status'];
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['gameId'] = this.gameId;
      data['nextPlayerId'] = this.nextPlayerId;
      data['status'] = this.status;
      return data;
    }
  }

  export interface IStepResult {
    gameId?: number;
    nextPlayerId?: number;
    status?: State;
  }

  export enum State {
    Continuation = 0,
    Winning = 1,
    Draw = 2,
    Loss = 3,
  }

  export class AddNewStepCommand implements IAddNewStepCommand {
    gameId?: number;
    playerId?: number;
    index?: number;

    constructor(data?: IAddNewStepCommand) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property)) {
            (<any> this)[property] = (<any> data)[property];
          }
        }
      }
    }

    static fromJS(data: any): AddNewStepCommand {
      data = typeof data === 'object' ? data : {};
      let result = new AddNewStepCommand();
      result.init(data);
      return result;
    }

    init(data?: any) {
      if (data) {
        this.gameId = data['gameId'];
        this.playerId = data['playerId'];
        this.index = data['index'];
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['gameId'] = this.gameId;
      data['playerId'] = this.playerId;
      data['index'] = this.index;
      return data;
    }
  }

  export interface IAddNewStepCommand {
    gameId?: number;
    playerId?: number;
    index?: number;
  }

  export class UserAuthData implements IUserAuthData {
    userName?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;

    constructor(data?: IUserAuthData) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property)) {
            (<any> this)[property] = (<any> data)[property];
          }
        }
      }
    }

    static fromJS(data: any): UserAuthData {
      data = typeof data === 'object' ? data : {};
      let result = new UserAuthData();
      result.init(data);
      return result;
    }

    init(data?: any) {
      if (data) {
        this.userName = data['userName'];
        this.password = data['password'];
        this.email = data['email'];
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data['userName'] = this.userName;
      data['password'] = this.password;
      data['email'] = this.email;
      return data;
    }
  }

  export interface IUserAuthData {
    userName?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;
  }

  export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
  }

  export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;
    protected isApiException = true;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
      super();

      this.message = message;
      this.status = status;
      this.response = response;
      this.headers = headers;
      this.result = result;
    }

    static isApiException(obj: any): obj is ApiException {
      return obj.isApiException === true;
    }
  }

  function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined) {
      return _observableThrow(result);
    } else {
      return _observableThrow(new ApiException(message, status, response, headers, null));
    }
  }

  function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
      if (!blob) {
        observer.next("");
        observer.complete();
      } else {
        let reader = new FileReader();
        reader.onload = event => {
          observer.next((<any> event.target).result);
          observer.complete();
        };
        reader.readAsText(blob);
      }
    });
  }

}
